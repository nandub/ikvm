<?xml version="1.0" encoding="utf-8" ?> 
<!--
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@frijters.net
  
-->
<root>
	<assembly>
		<class name="java.lang.Object" shadows="System.Object, mscorlib" modifiers="public">
			<constructor sig="()V" modifiers="public" />
			<method name="notifyAll" sig="()V" modifiers="public final">
				<body>
					<ldarg_0 />
					<call type="System.Threading.Monitor, mscorlib" name="PulseAll" sig="(Ljava.lang.Object;)V" />
					<ret />
				</body>
			</method>
			<method name="notify" sig="()V" modifiers="public final">
				<body>
					<ldarg_0 />
					<call type="System.Threading.Monitor, mscorlib" name="Pulse" sig="(Ljava.lang.Object;)V" />
					<ret />
				</body>
			</method>
			<method name="wait" sig="()V" modifiers="public final">
				<throws class="java.lang.InterruptedException" />
				<body>
					<ldarg_0 />
					<call type="System.Threading.Monitor, mscorlib" name="Wait" sig="(Ljava.lang.Object;)Z" />
					<!-- For some reason, Wait returns a boolean -->
					<pop />
					<ret />
				</body>
			</method>
			<method name="wait" sig="(J)V" modifiers="public final">
				<throws class="java.lang.InterruptedException" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldc_i4_0 />
					<call class="java.lang.ObjectHelper" name="wait" sig="(Ljava.lang.Object;JI)V" />
					<ret />
				</body>
			</method>
			<method name="wait" sig="(JI)V" modifiers="public final">
				<throws class="java.lang.InterruptedException" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldarg_2 />
					<call class="java.lang.ObjectHelper" name="wait" sig="(Ljava.lang.Object;JI)V" />
					<ret />
				</body>
			</method>
			<method name="getClass" sig="()Ljava.lang.Class;" modifiers="public final">
				<body>
					<ldarg_0 />
					<call type="System.Object, mscorlib" name="GetType" />
					<call type="IKVM.NativeCode.java.lang.VMClass" name="getClassFromType" />
					<castclass class="java.lang.Class" />
					<ret />
				</body>
			</method>
			<method name="clone" sig="()Ljava.lang.Object;" modifiers="protected">
				<throws class="java.lang.CloneNotSupportedException" />
				<body>
					<ldarg_0 />
					<isinst class="java.lang.Cloneable" />
					<brtrue name="ok" />
					<newobj class="java.lang.CloneNotSupportedException" name="&lt;init&gt;" sig="()V" />
					<throw />
					<label name="ok" />
					<ldarg_0 />
					<call type="System.Object, mscorlib" name="MemberwiseClone" />
					<ret />
				</body>
				<alternateBody>
					<ldarg_0 />
					<isinst type="System.Array, mscorlib" />
					<dup />
					<brtrue name="ok" />
					<newobj class="java.lang.CloneNotSupportedException" name="&lt;init&gt;" sig="()V" />
					<throw />
					<label name="ok" />
					<call type="System.Array, mscorlib" name="Clone" sig="()Ljava.lang.Object;" />
					<ret />
				</alternateBody>
			</method>
			<method name="toString" sig="()Ljava.lang.String;" modifiers="public">
				<override name="ToString" />
				<body>
					<ldarg_0 />
					<call class="java.lang.ObjectHelper" name="toStringSpecial" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
					<ret />
				</body>
				<alternateBody>
					<ldarg_0 />
					<isinst type="System.Array, mscorlib" />
					<brfalse name="skip" />
					<ldarg_0 />
					<call class="java.lang.ObjectHelper" name="toStringSpecial" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
					<br name="end" />
					<label name="skip" />
					<ldarg_0 />
					<callvirt type="System.Object, mscorlib" name="ToString" />
					<label name="end" />
					<ret />
				</alternateBody>
				<nonvirtualAlternateBody>
					<ldarg_0 />
					<call class="java.lang.ObjectHelper" name="toStringSpecial" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
					<ret />
				</nonvirtualAlternateBody>
			</method>
			<method name="hashCode" sig="()I" modifiers="public">
				<override name="GetHashCode" />
			</method>
			<method name="equals" sig="(Ljava.lang.Object;)Z" modifiers="public">
				<override name="Equals" />
			</method>
			<method name="finalize" sig="()V" modifiers="protected">
				<throws class="java.lang.Throwable" />
				<!-- NOTE we don't override Finalize, because that would be bad for performance,
					 instead, the compiler contains a hack to lazily override Finalize when a class
					 overrides our finalize
					 TODO consider adding code to constructor (in debug builds) to detect that someone
					 has overriden our finalize from another .NET language (if no intermediate Java base class
					 has overriden finalize, the lazy override of Object.Finalize hasn't kicked in and finalize
					 will never be called)
				-->
				<body>
					<ldarg_0 />
					<call type="System.Object, mscorlib" name="Finalize" />
					<ret />
				</body>
				<alternateBody>
					<!-- if code in the java.lang package explicitly invokes finalize on a non java.lang.Object
						 derived object	we just ignore it -->
					<ret />
				</alternateBody>
			</method>
		</class>
		<class name="java.lang.String" shadows="System.String, mscorlib" modifiers="public final">
			<implements class="java.lang.Comparable" />
			<implements class="java.lang.CharSequence" />
			<implements class="java.io.Serializable" />
			<field name="serialVersionUID" sig="J" modifiers="private static final" constant="-6849794470754667710" />
			<constructor sig="()V" modifiers="public">
				<alternateBody>
					<ldstr value="" />
					<call type="System.String, mscorlib" name="Copy" />
					<ret />
				</alternateBody>
			</constructor>
			<constructor sig="([C)V" modifiers="public">
                <alternateBody>
					<!-- force a NullPointerException if the array is null -->
					<ldarg_0 />
					<ldlen />
					<pop />
					<ldarg_0 />
					<newobj type="System.String, mscorlib" name=".ctor" sig="([C)V" />
					<ret />
				</alternateBody>
			</constructor>
			<constructor sig="([CII)V" modifiers="public" />
			<!-- Package private constructor, that we redirect to static helper -->
			<constructor sig="([CIIZ)V" modifiers="">
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([CIIZ)Ljava.lang.String;" />
			</constructor>
			<constructor sig="(Ljava.lang.String;)V" modifiers="public">
				<redirect class="System.String, mscorlib" name="Copy" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</constructor>
			<constructor sig="(Ljava.lang.StringBuffer;)V" modifiers="public">
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="(Ljava.lang.StringBuffer;)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([B)V" modifiers="public">
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([B)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BI)V" modifiers="public">
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BI)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BII)V" modifiers="public">
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BII)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BIII)V" modifiers="public">
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BIII)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BLjava.lang.String;)V" modifiers="public">
				<throws class="java.io.UnsupportedEncodingException" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BLjava.lang.String;)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BIILjava.lang.String;)V" modifiers="public">
				<throws class="java.io.UnsupportedEncodingException" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BIILjava.lang.String;)Ljava.lang.String;" />
			</constructor>
			<method name="hashCode" sig="()I" modifiers="public">
				<body>
					<ldarg_0 />
					<call class="java.lang.StringHelper" name="hashCode" sig="(Lcli.System.String;)I" />
					<ret />
				</body>
			</method>
			<!-- we have a toString here to make sure that it shows up as a declared method in reflection -->
			<method name="toString" sig="()Ljava.lang.String;" modifiers="public" />
			<!-- we have an equals here to make sure that it shows up as a declared method in reflection -->
			<method name="equals" sig="(Ljava.lang.Object;)Z" modifiers="public" />
			<method name="valueOf" sig="(Z)Ljava.lang.String;" modifiers="public static">
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(I)Ljava.lang.String;" modifiers="public static">
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(J)Ljava.lang.String;" modifiers="public static">
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(C)Ljava.lang.String;" modifiers="public static">
				<redirect class="java.lang.StringHelper" sig="(C)Lcli.System.String;" />
			</method>
			<method name="valueOf" sig="(F)Ljava.lang.String;" modifiers="public static">
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(D)Ljava.lang.String;" modifiers="public static">
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="([C)Ljava.lang.String;" modifiers="public static">
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="([CII)Ljava.lang.String;" modifiers="public static">
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(Ljava.lang.Object;)Ljava.lang.String;" modifiers="public static">
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="substring" sig="(I)Ljava.lang.String;" modifiers="public">
				<redirect name="Substring" />
			</method>
			<method name="length" sig="()I" modifiers="public">
				<redirect name="get_Length" />
			</method>
			<method name="charAt" sig="(I)C" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;I)C" />
			</method>
			<method name="substring" sig="(II)Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II)Ljava.lang.String;" />
			</method>
			<method name="indexOf" sig="(I)I" modifiers="public">
				<body>
					<ldarg_1 />
					<ldc_i4 value="65535" />
					<ble_un name="ok" />
					<ldc_i4_m1 />
					<ret />
					<label name="ok" />
					<ldarg_0 />
					<ldarg_1 />
					<call type="System.String, mscorlib" name="IndexOf" sig="(C)I" />
					<ret />
				</body>
			</method>
			<method name="indexOf" sig="(II)I" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II)I" />
			</method>
			<method name="indexOf" sig="(Ljava.lang.String;)I" modifiers="public">
				<redirect name="IndexOf" />
			</method>
			<method name="indexOf" sig="(Ljava.lang.String;I)I" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;Ljava.lang.String;I)I" />
			</method>
			<method name="lastIndexOf" sig="(I)I" modifiers="public">
				<body>
					<ldarg_1 />
					<ldc_i4 value="65535" />
					<ble_un name="ok" />
					<ldc_i4_m1 />
					<ret />
					<label name="ok" />
					<ldarg_0 />
					<ldarg_1 />
					<call type="System.String, mscorlib" name="LastIndexOf" sig="(C)I" />
					<ret />
				</body>
			</method>
			<method name="lastIndexOf" sig="(II)I" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II)I" />
			</method>
			<method name="lastIndexOf" sig="(Ljava.lang.String;)I" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;Ljava.lang.String;)I" />
			</method>
			<method name="lastIndexOf" sig="(Ljava.lang.String;I)I" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;Ljava.lang.String;I)I" />
			</method>
			<method name="toCharArray" sig="()[C" modifiers="public">
				<redirect name="ToCharArray" />
			</method>
			<method name="getChars" sig="(II[CI)V" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II[CI)V" />
			</method>
			<method name="startsWith" sig="(Ljava.lang.String;)Z" modifiers="public">
				<redirect name="StartsWith" />
			</method>
			<method name="startsWith" sig="(Ljava.lang.String;I)Z" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;Ljava.lang.String;I)Z" />
			</method>
			<method name="endsWith" sig="(Ljava.lang.String;)Z" modifiers="public">
				<redirect name="EndsWith" />
			</method>
			<method name="toUpperCase" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="toUpperCase" sig="(Ljava.util.Locale;)Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.util.Locale;)Ljava.lang.String;" />
			</method>
			<method name="toLowerCase" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="toLowerCase" sig="(Ljava.util.Locale;)Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.util.Locale;)Ljava.lang.String;" />
			</method>
			<method name="compareToIgnoreCase" sig="(Ljava.lang.String;)I" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
			</method>
			<method name="equalsIgnoreCase" sig="(Ljava.lang.String;)Z" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)Z" />
			</method>
			<method name="intern" sig="()Ljava.lang.String;" modifiers="public">
				<redirect type="static" name="Intern" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="compareTo" sig="(Ljava.lang.String;)I" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
			</method>
			<method name="compareTo" sig="(Ljava.lang.Object;)I" modifiers="public">
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<castclass type="System.String, mscorlib" />
					<call class="java.lang.StringHelper" name="compareTo" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
					<ret />
				</body>
			</method>
			<method name="replace" sig="(CC)Ljava.lang.String;" modifiers="public">
				<redirect name="Replace" />
			</method>
			<method name="getBytes" sig="()[B" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)[B" />
			</method>
			<method name="getBytes" sig="(Ljava.lang.String;)[B" modifiers="public">
				<throws class="java.io.UnsupportedEncodingException" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)[B" />
			</method>
			<method name="subSequence" sig="(II)Ljava.lang.CharSequence;" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" name="substring" sig="(Lcli.System.String;II)Ljava.lang.String;" />
			</method>
			<method name="trim" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="regionMatches" sig="(ZILjava.lang.String;II)Z" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;ZILjava.lang.String;II)Z" />
			</method>
			<method name="regionMatches" sig="(ILjava.lang.String;II)Z" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;ILjava.lang.String;II)Z" />
			</method>
			<method name="getBytes" sig="(II[BI)V" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;II[BI)V" />
			</method>
			<method name="concat" sig="(Ljava.lang.String;)Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="contentEquals" sig="(Ljava.lang.StringBuffer;)Z" modifiers="public">
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<callvirt class="java.lang.StringBuffer" name="toString" sig="()Ljava.lang.String;" />
					<callvirt type="System.String, mscorlib" name="Equals" sig="(Ljava.lang.String;)Z" />
					<ret />
				</body>
			</method>
			<method name="matches" sig="(Ljava.lang.String;)Z" modifiers="public">
				<body>
					<ldarg_1 />
					<ldarg_0 />
					<call class="java.util.regex.Pattern" name="matches" sig="(Ljava.lang.String;Ljava.lang.CharSequence;)Z" />
					<ret />
				</body>
			</method>
			<method name="replaceAll" sig="(Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" modifiers="public">
				<body>
					<ldarg_1 />
					<call class="java.util.regex.Pattern" name="compile" sig="(Ljava.lang.String;)Ljava.util.regex.Pattern;" />
					<ldarg_0 />
					<callvirt class="java.util.regex.Pattern" name="matcher" sig="(Ljava.lang.CharSequence;)Ljava.util.regex.Matcher;" />
					<ldarg_2 />
					<callvirt class="java.util.regex.Matcher" name="replaceAll" sig="(Ljava.lang.String;)Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="replaceFirst" sig="(Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" modifiers="public">
				<body>
					<ldarg_1 />
					<call class="java.util.regex.Pattern" name="compile" sig="(Ljava.lang.String;)Ljava.util.regex.Pattern;" />
					<ldarg_0 />
					<callvirt class="java.util.regex.Pattern" name="matcher" sig="(Ljava.lang.CharSequence;)Ljava.util.regex.Matcher;" />
					<ldarg_2 />
					<callvirt class="java.util.regex.Matcher" name="replaceFirst" sig="(Ljava.lang.String;)Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="split" sig="(Ljava.lang.String;)[Ljava.lang.String;" modifiers="public">
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldc_i4_0 />
					<callvirt class="java.lang.String" name="split" sig="(Ljava.lang.String;I)[Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="split" sig="(Ljava.lang.String;I)[Ljava.lang.String;" modifiers="public">
				<body>
					<ldarg_1 />
					<call class="java.util.regex.Pattern" name="compile" sig="(Ljava.lang.String;)Ljava.util.regex.Pattern;" />
					<ldarg_0 />
					<ldarg_2 />
					<callvirt class="java.util.regex.Pattern" name="split" sig="(Ljava.lang.CharSequence;I)[Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="copyValueOf" sig="([C)Ljava.lang.String;" modifiers="public static">
				<body>
					<!-- force a NullPointerException if the array is null -->
					<ldarg_0 />
					<ldlen />
					<pop />
					<ldarg_0 />
					<newobj type="System.String, mscorlib" name=".ctor" sig="([C)V" />
					<ret />
				</body>
			</method>
			<method name="copyValueOf" sig="([CII)Ljava.lang.String;" modifiers="public static">
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldarg_2 />
					<newobj type="System.String, mscorlib" name=".ctor" sig="([CII)V" />
					<ret />
				</body>
			</method>
			<field name="CASE_INSENSITIVE_ORDER" sig="Ljava.util.Comparator;" modifiers="public static final" />
			<!-- NOTE we're redirecting fields to static methods here!
				NOTE only reading fields can be redirected
			-->
			<field name="count" sig="I" modifiers="">
				<redirect class="java.lang.StringHelper" type="static" name="GetCountField" sig="(Lcli.System.String;)I" />
			</field>
			<!-- Making a new char array instead of directly accessing the contents of the string, probably isn't
				as efficient as the coder of this construct wished for, but hey ;-) At least it works...
			-->
			<method name="zeroBasedStringValue" sig="(Ljava.lang.String;)[C" modifiers="static">
				<body>
					<ldarg_0 />
					<call type="System.String, mscorlib" name="ToCharArray" sig="()[C" />
					<ret />
				</body>
			</method>
			<!-- NOTE value and offset aren't used anymore in Classpath's StringBuffer, so we should drop them -->
			<field name="value" sig="[C" modifiers="">
				<redirect class="java.lang.StringHelper" type="static" name="GetValueField" sig="(Lcli.System.String;)[C" />
			</field>
			<field name="offset" sig="I" modifiers="">
				<redirect class="java.lang.StringHelper" type="static" name="GetOffsetField" sig="(Lcli.System.String;)I" />
			</field>
			<!-- TODO mark this method as BeforeFieldInit (and benchmark to see if that is faster) -->
			<clinit>
				<body>
					<newobj class="java.lang.String$CaseInsensitiveComparator" name="&lt;init&gt;" sig="()V" />
					<stsfld class="java.lang.String" name="CASE_INSENSITIVE_ORDER" sig="Ljava.util.Comparator;" />
					<ret />
				</body>
			</clinit>
		</class>
		<class name="java.lang.Throwable" shadows="System.Exception, mscorlib" modifiers="public">
			<implements class="java.io.Serializable" />
			<field name="serialVersionUID" sig="J" modifiers="private static final" constant="-3042686055658047285" />
			<field name="serialPersistentFields" sig="[Ljava.io.ObjectStreamField;" modifiers="private static final" />
			<clinit>
				<body>
					<call class="java.lang.ExceptionHelper" name="getPersistentFields" sig="()[Ljava.io.ObjectStreamField;" />
					<stsfld class="java.lang.Throwable" name="serialPersistentFields" sig="[Ljava.io.ObjectStreamField;" />
					<ret />
				</body>
			</clinit>
			<method name="readObject" sig="(Ljava.io.ObjectInputStream;)V" modifiers="private">
				<throws class="java.io.IOException" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="readObject" sig="(Ljava.lang.Throwable;Ljava.io.ObjectInputStream;)V" />
					<ret />
				</body>
			</method>
			<method name="writeObject" sig="(Ljava.io.ObjectOutputStream;)V" modifiers="private">
				<throws class="java.io.IOException" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="writeObject" sig="(Ljava.lang.Throwable;Ljava.io.ObjectOutputStream;)V" />
					<ret />
				</body>
			</method>
			<constructor sig="()V" modifiers="public">
				<body>
					<ldarg_0 />
					<call class="java.lang.ExceptionHelper" name="get_NullString" sig="()Ljava.lang.String;" />
					<call type="System.Exception, mscorlib" name=".ctor" sig="(Ljava.lang.String;)V" />
					<ret />
				</body>
			</constructor>
			<constructor sig="(Ljava.lang.String;)V" modifiers="public">
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="FilterMessage" sig="(Ljava.lang.String;)Ljava.lang.String;" />
					<call type="System.Exception, mscorlib" name=".ctor" sig="(Ljava.lang.String;)V" />
					<ret />
				</body>
			</constructor>
			<constructor sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" modifiers="public">
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="FilterMessage" sig="(Ljava.lang.String;)Ljava.lang.String;" />
					<ldarg_2 />
					<call type="System.Exception, mscorlib" name=".ctor" sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" />
					<ldarg_2 />
					<brtrue name="skip" />
					<ldarg_0 />
					<ldarg_2 />
					<call class="java.lang.ExceptionHelper" name="initCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
					<pop />
					<label name="skip" />
					<ret />
				</body>
			</constructor>
			<constructor sig="(Ljava.lang.Throwable;)V" modifiers="public">
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="GetMessageFromCause" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" />
					<ldarg_1 />
					<call type="System.Exception, mscorlib" name=".ctor" sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" />
					<ldarg_1 />
					<brtrue name="skip" />
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="initCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
					<pop />
					<label name="skip" />
					<ret />
				</body>
			</constructor>
			<method type="virtual" name="printStackTrace" sig="()V" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)V" type="static" />
			</method>
			<method type="virtual" name="printStackTrace" sig="(Ljava.io.PrintStream;)V" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.io.PrintStream;)V" type="static" />
			</method>
			<method type="virtual" name="printStackTrace" sig="(Ljava.io.PrintWriter;)V" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.io.PrintWriter;)V" type="static" />
			</method>
			<method type="virtual" name="getMessage" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
			</method>
			<method type="virtual" name="getLocalizedMessage" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
			</method>
			<method type="virtual" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" type="static" />
			</method>
			<method type="virtual" name="initCause" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" type="static" />
			</method>
			<method type="virtual" name="getCause" sig="()Ljava.lang.Throwable;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" type="static" />
			</method>
			<method type="virtual" name="getStackTrace" sig="()[Ljava.lang.StackTraceElement;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)[Ljava.lang.StackTraceElement;" type="static" />
			</method>
			<method type="virtual" name="setStackTrace" sig="([Ljava.lang.StackTraceElement;)V" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;[Ljava.lang.StackTraceElement;)V" type="static" />
			</method>
			<method type="virtual" name="toString" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
			</method>
		</class>
		<class name="java.lang.Comparable" shadows="System.IComparable, mscorlib" modifiers="public abstract interface">
			<method name="compareTo" sig="(Ljava.lang.Object;)I" modifiers="public abstract">
				<override name="CompareTo" />
			</method>
		</class>
		<class name="gnu.classpath.RawData" shadows="System.IntPtr, mscorlib" scope="private">
			<!-- TODO custom boxing isn't support for non-private remapped types, but since this is the only
			     type that has a custom boxing rule, this isn't yet an issue -->
			<box>
				<!-- We special case boxing, to "box" IntPtr.Zero as null -->
				<dup />
				<brfalse name="null" />
				<box type="System.IntPtr, mscorlib" />
				<br name="end" />
				<label name="null" />
				<pop />
				<ldnull />
				<label name="end" />
			</box>
		</class>
		<!-- This is where the "native" helper methods start -->
		<class name="ikvm.lang.CIL">
			<method name="unbox_byte" sig="(Ljava.lang.Object;)B">
				<body>
					<ldarg_0 />
					<unbox type="System.SByte, mscorlib" />
					<ldind_i1 />
					<ret />
				</body>
			</method>
			<method name="unbox_boolean" sig="(Ljava.lang.Object;)Z">
				<body>
					<ldarg_0 />
					<unbox type="System.Boolean, mscorlib" />
					<ldind_i1 />
					<ret />
				</body>
			</method>
			<method name="unbox_short" sig="(Ljava.lang.Object;)S">
				<body>
					<ldarg_0 />
					<unbox type="System.Int16, mscorlib" />
					<ldind_i2 />
					<ret />
				</body>
			</method>
			<method name="unbox_char" sig="(Ljava.lang.Object;)C">
				<body>
					<ldarg_0 />
					<unbox type="System.Char, mscorlib" />
					<ldind_i2 />
					<ret />
				</body>
			</method>
			<method name="unbox_int" sig="(Ljava.lang.Object;)I">
				<body>
					<ldarg_0 />
					<unbox type="System.Int32, mscorlib" />
					<ldind_i4 />
					<ret />
				</body>
			</method>
			<method name="unbox_float" sig="(Ljava.lang.Object;)F">
				<body>
					<ldarg_0 />
					<unbox type="System.Single, mscorlib" />
					<ldind_r4 />
					<ret />
				</body>
			</method>
			<method name="unbox_long" sig="(Ljava.lang.Object;)J">
				<body>
					<ldarg_0 />
					<unbox type="System.Int64, mscorlib" />
					<ldind_i8 />
					<ret />
				</body>
			</method>
			<method name="unbox_double" sig="(Ljava.lang.Object;)D">
				<body>
					<ldarg_0 />
					<unbox type="System.Double, mscorlib" />
					<ldind_r8 />
					<ret />
				</body>
			</method>
			<method name="box_byte" sig="(B)Ljava.lang.Object;">
				<body>
					<ldarg_0 />
					<box type="System.SByte, mscorlib" />
					<ret />
				</body>
			</method>
			<method name="box_boolean" sig="(Z)Ljava.lang.Object;">
				<body>
					<ldarg_0 />
					<box type="System.Boolean, mscorlib" />
					<ret />
				</body>
			</method>
			<method name="box_short" sig="(S)Ljava.lang.Object;">
				<body>
					<ldarg_0 />
					<box type="System.Int16, mscorlib" />
					<ret />
				</body>
			</method>
			<method name="box_char" sig="(C)Ljava.lang.Object;">
				<body>
					<ldarg_0 />
					<box type="System.Char, mscorlib" />
					<ret />
				</body>
			</method>
			<method name="box_int" sig="(I)Ljava.lang.Object;">
				<body>
					<ldarg_0 />
					<box type="System.Int32, mscorlib" />
					<ret />
				</body>
			</method>
			<method name="box_float" sig="(F)Ljava.lang.Object;">
				<body>
					<ldarg_0 />
					<box type="System.Single, mscorlib" />
					<ret />
				</body>
			</method>
			<method name="box_long" sig="(J)Ljava.lang.Object;">
				<body>
					<ldarg_0 />
					<box type="System.Int64, mscorlib" />
					<ret />
				</body>
			</method>
			<method name="box_double" sig="(D)Ljava.lang.Object;">
				<body>
					<ldarg_0 />
					<box type="System.Double, mscorlib" />
					<ret />
				</body>
			</method>
			<method name="box_ubyte" sig="(B)Lcli.System.Byte;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_ushort" sig="(S)Lcli.System.UInt16;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_uint" sig="(I)Lcli.System.UInt32;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_ulong" sig="(J)Lcli.System.UInt64;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="unbox_ubyte" sig="(Lcli.System.Byte;)B">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="unbox_ushort" sig="(Lcli.System.UInt16;)S">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="unbox_uint" sig="(Lcli.System.UInt32;)I">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="unbox_ulong" sig="(Lcli.System.UInt64;)J">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
		</class>
		<class name="ikvm.lang.ByteArrayHack">
			<method name="cast" sig="([B)[Lcli.System.Byte;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="cast" sig="([Lcli.System.Byte;)[B">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
		</class>
	</assembly>
	<exceptionMappings>
		<exception src="System.NullReferenceException, mscorlib" dst="java.lang.NullPointerException" />
		<!-- many of the String and Object methods throw ArgumentNullException where Java throws an NPE -->
		<exception src="System.ArgumentNullException, mscorlib" dst="java.lang.NullPointerException" />
		<exception src="System.IndexOutOfRangeException, mscorlib" dst="java.lang.ArrayIndexOutOfBoundsException" />
		<!-- HACK for String methods, we remap ArgumentOutOfRangeException to StringIndexOutOfBoundsException -->
		<exception src="System.ArgumentOutOfRangeException, mscorlib" dst="java.lang.StringIndexOutOfBoundsException" />
		<exception src="System.InvalidCastException, mscorlib" dst="java.lang.ClassCastException" />
		<!-- NOTE we "map" to java.lang.Error, because that is the base class of all possible mappings.
			The * in front of the class name means that all subclasses can be thrown as well.
		 -->
		<exception src="System.TypeInitializationException, mscorlib" dst="*java.lang.Error">
			<code>
				<call type="System.Exception, mscorlib" name="get_InnerException" sig="()Ljava.lang.Throwable;" />
				<call class="java.lang.ExceptionHelper" name="MapExceptionFast" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
				<dup />
				<isinst class="java.lang.Error" />
				<brtrue name="end" />
				<newobj class="java.lang.ExceptionInInitializerError" name="&lt;init&gt;" sig="(Ljava.lang.Throwable;)V" />
				<label name="end" />
			</code>
		</exception>
		<exception src="System.Threading.SynchronizationLockException, mscorlib" dst="java.lang.IllegalMonitorStateException" />
		<exception src="System.Threading.ThreadInterruptedException, mscorlib" dst="java.lang.InterruptedException" />
		<exception src="System.OutOfMemoryException, mscorlib" dst="java.lang.OutOfMemoryError" />
		<exception src="System.DivideByZeroException, mscorlib" dst="java.lang.ArithmeticException">
			<code>
				<pop />
				<ldstr value="/ by zero" />
				<newobj class="java.lang.ArithmeticException" name="&lt;init&gt;" sig="(Ljava.lang.String;)V" />
			</code>
		</exception>
		<exception src="System.ArrayTypeMismatchException, mscorlib" dst="java.lang.ArrayStoreException" />
		<exception src="System.StackOverflowException, mscorlib" dst="java.lang.StackOverflowError" />
		<exception src="System.Security.VerificationException, mscorlib" dst="java.lang.VerifyError" />
		<exception src="System.Threading.ThreadAbortException, mscorlib" dst="java.lang.ThreadDeath">
			<code>
				<castclass type="System.Threading.ThreadAbortException, mscorlib" />
				<call type="System.Threading.ThreadAbortException, mscorlib" name="get_ExceptionState" sig="()Ljava.lang.Object;" />
				<isinst class="java.lang.ThreadDeath" />
				<dup />
				<brtrue name="end" />
				<pop />
				<newobj class="java.lang.ThreadDeath" name="&lt;init&gt;" sig="()V" />
				<label name="end" />
				<!-- NOTE we do this last because ResetAbort clears the ExceptionState of the ThreadAbortException (why?) -->
				<!-- TODO we should put an exception handler around the ResetAbort call, because it will throw a ThreadStateException
				     if no Abort is pending (someone could have thrown the exception manually, or we could have called on a 
				     previous handler that turned out not to be match for this exception type) -->
				<stloc name="x" class="java.lang.ThreadDeath" />
				<exceptionBlock>
					<try>
						<!-- TODO instead of catching the ThreadStateException, we should check the ThreadState
						     before calling ResetAbort -->
						<call type="System.Threading.Thread, mscorlib" name="ResetAbort" sig="()V" />
					</try>
					<catch type="System.Threading.ThreadStateException, mscorlib">
						<!-- ignore the exception -->
					</catch>
				</exceptionBlock>
				<ldloc name="x" />
			</code>
		</exception>
		<!-- TODO make sure the originating method was from an IKVM.NET generated assembly, because if it was
	    generated by non-Java code, this remapping is obviously bogus. -->
		<exception src="System.OverflowException, mscorlib" dst="java.lang.NegativeArraySizeException" />
	</exceptionMappings>
</root>
