<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.2//EN" "http://apache.org/forrest/dtd/document-v12.dtd">
<document> 
  <header> 
    <title>IKVM.NET Concepts</title> 
    <authors><person name="Stephen Schaub" email="sschaub@bju.edu"/> 
    </authors> 
     <abstract>This section discusses several important concepts about
     the capabilities and limitations of IKVM.NET. </abstract>
  </header> 
  <body> 
    <section>
      <title>Class Loading</title>
      
      <p>IKVM.NET fully supports dynamic Java class loading, both in Java applications running in the ikvm 
      JVM, as well as in Java applications which have been converted to .NET CIL using ikvmc. 
      </p>
      
      <section>
        <title>Class Loading in Dynamically Interpreted Java Applications</title>
        <p>When you run a Java application using ikvm, ikvm finds and loads Java .class files much like
        other Java VM's. See the <link href="site:ikvm">ikvm notes</link> for details.</p>
      </section>

      <section>
        <title>Class Loading in ikvmc-compiled Java Applications</title>
        <p>When you convert a Java application to CIL using ikvmc, it executes as "native" .NET code. Applications that
        use the Java classloading API (<code>Class.forName( )</code>, and so forth) locate classes using the following algorithm:</p>
        <ol>
          <li>All loaded assemblies are searched first. Thus, if the class exists in the .exe or any referenced dll's,
            it will be found there.</li>
          <li>If the class is not in a loaded assembly, the CLASSPATH is searched for a Java .class. If found, it is dynamically loaded
            and executed using the IKVM interpreter.</li>
        </ol>
        
        <p>This approach means you can develop .NET applications in Java that execute at native .NET speeds, but enjoy the flexibility
        of dynamic class loading at runtime. For example, you can write a .NET application that loads type-4 JDBC drivers dynamically.</p>
        
        <p>For the most part, all of this works the way you want without much thought on your part. But there are a few situations
        that will require special handling.  Consider, for example, an application that has been compiled by ikvmc into several assemblies, A.exe, B.dll, and C.dll. 
        A.exe references B.dll, but neither A.exe nor B.dll reference C.dll directly (perhaps C.dll is a JDBC driver).
        If code in A.exe uses Class.forName( ) to load a class in B.dll, everything is fine. 
        But if code in A.exe or B.dll uses Class.forName( ) to load classes in C.dll, things are not fine. Since neither A.exe nor B.dll references
        C.dll, it will not have been loaded into the application domain at runtime, and the application will fail with a Class Not Found
        runtime exception.</p>
        <p>In cases like this, your application must force the runtime to load an assembly into the application domain before calling
        Class.forName( ). To do this, call <strong>TODO: Insert API method here</strong>.</p>
      </section>
    
    </section>
    
    <section>
      <title>Debugging Support</title>
      <p>Java applications converted to CIL using ikvmc with the -debug option can be debugged using standard .NET / Mono debugging
      tools. Remember to compile the Java source code using the appropriate debug option (javac: -g or jikes: -g:lines,vars,source).</p>
    </section>
  </body>
</document>
